"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var merge = require("merge2");
/**
 * Storages and registers all gulp classes and their tasks.
 */
var MetadataStorage = /** @class */ (function () {
    function MetadataStorage() {
        // -------------------------------------------------------------------------
        // Properties
        // -------------------------------------------------------------------------
        this.gulpclassMetadatas = [];
        this.taskMetadatas = [];
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    MetadataStorage.prototype.addGulpclassMetadata = function (metadata) {
        var _this = this;
        this.gulpclassMetadatas.push(metadata);
        this.taskMetadatas
            .filter(function (taskMetadata) { return taskMetadata.classConstructor === metadata.classConstructor; })
            .forEach(function (taskMetadata) { return _this.registerTasks(metadata, taskMetadata); });
    };
    MetadataStorage.prototype.addTaskMetadata = function (metadata) {
        this.taskMetadatas.push(metadata);
        var gulpclassMetadata = this.gulpclassMetadatas.reduce(function (found, m) {
            return m.classConstructor === metadata.classConstructor ? m : found;
        }, undefined);
        if (gulpclassMetadata)
            this.registerTasks(gulpclassMetadata, metadata);
    };
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    MetadataStorage.prototype.registerTasks = function (gulpclassMetadata, taskMetadata) {
        var _this = this;
        if (!gulpclassMetadata.classInstance)
            gulpclassMetadata.classInstance = new gulpclassMetadata.classConstructor();
        if (taskMetadata.dependencies && taskMetadata.dependencies.length) {
            gulpclassMetadata.gulpInstance.task(taskMetadata.name, taskMetadata.dependencies, function (cb) {
                return _this.executeTask(gulpclassMetadata, taskMetadata, cb);
            });
        }
        else {
            gulpclassMetadata.gulpInstance.task(taskMetadata.name, function (cb) {
                return _this.executeTask(gulpclassMetadata, taskMetadata, cb);
            });
        }
    };
    MetadataStorage.prototype.executeTask = function (gulpclassMetadata, taskMetadata, cb) {
        var methodResult = gulpclassMetadata.classInstance[taskMetadata.method](cb);
        if (taskMetadata.isSequence && methodResult instanceof Array) {
            return gulpclassMetadata.gulpInstance.series.apply(this, methodResult)(cb);
        }
        else if (taskMetadata.isMerge && methodResult instanceof Array) {
            return merge.apply(this, methodResult);
        }
        else {
            return methodResult;
        }
    };
    return MetadataStorage;
}());
exports.MetadataStorage = MetadataStorage;
/**
 * Default metadata storage is used as singleton and can be used to storage all metadatas.
 */
exports.defaultMetadataStorage = new MetadataStorage();
//# sourceMappingURL=MetadataStorage.js.map