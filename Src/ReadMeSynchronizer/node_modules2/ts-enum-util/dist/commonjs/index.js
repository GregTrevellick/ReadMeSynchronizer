"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A generic wrapper for any enum-like object (see {@link EnumLike}).
 * Provides utilities for runtime processing of an enum's values and keys, with strict compile-time
 * type safety.
 *
 * EnumWrapper cannot be directly instantiated. Use one of the following to get/create an EnumWrapper
 * instance:
 * - {@link $enum}
 * - {@link EnumWrapper.getCachedInstance}
 *
 * @template V - Type of the enum value.
 * @template T - Type of the enum-like object that is being wrapped.
 */
var EnumWrapper = /** @class */ (function () {
    /**
     * Create a new EnumWrapper instance.
     * This is for internal use only.
     * Use one of the following to publicly get/create an EnumWrapper
     * instance:
     * - {@link $enum}
     * - {@link EnumWrapper.getCachedInstance}
     *
     * @param enumObj - An enum-like object. See the {@link EnumLike} type for more explanation.
     */
    function EnumWrapper(enumObj) {
        this.enumObj = enumObj;
        this.keysList = Object.freeze(Object.keys(enumObj)
            // Include only keys that are not index keys.
            // This is necessary to ignore the reverse-lookup entries that are automatically added
            // by TypeScript to numeric enums.
            .filter(isNonIndexKey)
            // Order of Object.keys() is implementation-dependent, so sort the keys to guarantee
            // a consistent order for iteration.
            .sort());
        var length = this.keysList.length;
        var valuesList = new Array(length);
        var keysByValueMap = new Map();
        // According to multiple tests found on jsperf.com, a plain for loop is faster than using
        // Array.prototype.forEach
        for (var index = 0; index < length; ++index) {
            var key = this.keysList[index];
            var value = enumObj[key];
            valuesList[index] = value;
            keysByValueMap.set(value, key);
            // Type casting of "this" necessary to bypass readonly index signature for initialization.
            this[index] = Object.freeze([key, value]);
        }
        this.valuesList = Object.freeze(valuesList);
        this.keysByValueMap = keysByValueMap;
        this.size = this.length = length;
        // Make the EnumWrapper instance immutable
        Object.freeze(this);
    }
    /**
     * Gets a cached EnumWrapper for an enum-like object.
     * Creates and caches a new EnumWrapper if one is not already cached.
     * @param enumObj - An enum-like object.
     * @return An instance of EnumWrapper for the provided enumObj.
     */
    EnumWrapper.getCachedInstance = function (enumObj) {
        var result = EnumWrapper.instancesCache.get(enumObj);
        if (!result) {
            result = new EnumWrapper(enumObj);
            EnumWrapper.instancesCache.set(enumObj, result);
        }
        return result;
    };
    Object.defineProperty(EnumWrapper.prototype, Symbol.toStringTag, {
        get: function () {
            return "EnumWrapper";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return "[object EnumWrapper]"
     */
    EnumWrapper.prototype.toString = function () {
        // NOTE: overriding toString in addition to Symbol.toStringTag
        //       for maximum compatibility with older runtime environments
        //       that do not implement Object.prototype.toString in terms
        //       of Symbol.toStringTag
        return "[object EnumWrapper]";
    };
    /**
     * Get an iterator for this enum's keys.
     * Iteration order is based on sorted order of keys.
     * Part of the Map-like interface.
     * @return An iterator that iterates over this enum's keys.
     */
    EnumWrapper.prototype.keys = function () {
        var _a;
        var _this = this;
        var index = 0;
        return _a = {
                next: function () {
                    var isDone = index >= _this.length;
                    var result = {
                        done: isDone,
                        value: _this.keysList[index]
                    };
                    ++index;
                    return result;
                }
            },
            _a[Symbol.iterator] = function () {
                return this;
            },
            _a;
    };
    /**
     * Get an iterator for this enum's values.
     * Iteration order is based on sorted order of keys.
     * Part of the Map-like interface.
     * NOTE: If there are duplicate values in the enum, then there will also be duplicate values
     *       in the result.
     * @return An iterator that iterates over this enum's values.
     */
    EnumWrapper.prototype.values = function () {
        var _a;
        var _this = this;
        var index = 0;
        return _a = {
                next: function () {
                    var isDone = index >= _this.length;
                    var result = {
                        done: isDone,
                        value: _this.valuesList[index]
                    };
                    ++index;
                    return result;
                }
            },
            _a[Symbol.iterator] = function () {
                return this;
            },
            _a;
    };
    /**
     * Get an iterator for this enum's entries as [key, value] tuples.
     * Iteration order is based on sorted order of keys.
     * @return An iterator that iterates over this enum's entries as [key, value] tuples.
     */
    EnumWrapper.prototype.entries = function () {
        var _a;
        var _this = this;
        var index = 0;
        return _a = {
                next: function () {
                    var isDone = index >= _this.length;
                    var result = {
                        done: isDone,
                        // NOTE: defensive copy not necessary because entries are "frozen"
                        value: _this[index]
                    };
                    ++index;
                    return result;
                }
            },
            _a[Symbol.iterator] = function () {
                return this;
            },
            _a;
    };
    /**
     * Get an iterator for this enum's entries as [key, value] tuples.
     * Iteration order is based on sorted order of keys.
     * @return An iterator that iterates over this enum's entries as [key, value] tuples.
     */
    EnumWrapper.prototype[Symbol.iterator] = function () {
        return this.entries();
    };
    /**
     * Calls the provided iteratee on each item in this enum.
     * Iteration order is based on sorted order of keys.
     * See {@link EnumWrapper.Iteratee} for the signature of the iteratee.
     * The return value of the iteratee is ignored.
     * @param iteratee - The iteratee.
     * @param context - If provided, then the iteratee will be called with the context as its "this" value.
     */
    EnumWrapper.prototype.forEach = function (iteratee, context) {
        var length = this.length;
        // According to multiple tests found on jsperf.com, a plain for loop is faster than using
        // Array.prototype.forEach
        for (var index = 0; index < length; ++index) {
            var entry = this[index];
            iteratee.call(context, entry[1], entry[0], this, index);
        }
    };
    /**
     * Maps this enum's entries to a new list of values.
     * Iteration order is based on sorted order of keys.
     * Builds a new array containing the results of calling the provided iteratee on each item in this enum.
     * See {@link EnumWrapper.Iteratee} for the signature of the iteratee.
     * @param iteratee - The iteratee.
     * @param context - If provided, then the iteratee will be called with the context as its "this" value.
     * @return A new array containg the results of the iteratee.
     *
     * @template R - The of the mapped result for each entry.
     */
    EnumWrapper.prototype.map = function (iteratee, context) {
        var length = this.length;
        var result = new Array(length);
        // According to multiple tests found on jsperf.com, a plain for loop is faster than using Array.prototype.map
        for (var index = 0; index < length; ++index) {
            var entry = this[index];
            result[index] = iteratee.call(context, entry[1], entry[0], this, index);
        }
        return result;
    };
    /**
     * Get a list of this enum's keys.
     * Order of items in the list is based on sorted order of keys.
     * @return A list of this enum's keys.
     */
    EnumWrapper.prototype.getKeys = function () {
        // need to return a copy of this.keysList so it can be returned as Array instead of ReadonlyArray.
        return this.keysList.slice();
    };
    /**
     * Get a list of this enum's values.
     * Order of items in the list is based on sorted order of keys.
     * NOTE: If there are duplicate values in the enum, then there will also be duplicate values
     *       in the result.
     * @return A list of this enum's values.
     */
    EnumWrapper.prototype.getValues = function () {
        // need to return a copy of this.valuesList so it can be returned as Array instead of ReadonlyArray.
        return this.valuesList.slice();
    };
    /**
     * Get a list of this enum's entries as [key, value] tuples.
     * Order of items in the list is based on sorted order of keys.
     * @return A list of this enum's entries as [key, value] tuples.
     */
    EnumWrapper.prototype.getEntries = function () {
        // Create an array from the indexed entries of "this".
        // NOTE: no need for defensive copy of each entry because all entries are "frozen".
        return Array.prototype.slice.call(this);
    };
    /**
     * Tests if the provided string is actually a valid key for this enum
     * Acts as a type guard to confirm that the provided value is actually the enum key type.
     * @param key - A potential key value for this enum.
     * @return True if the provided key is a valid key for this enum.
     */
    EnumWrapper.prototype.isKey = function (key) {
        return (key != null &&
            isNonIndexKey(key) &&
            this.enumObj.hasOwnProperty(key));
    };
    /**
     * Casts a string to a properly-typed key for this enum.
     * Throws an error if the key is invalid.
     * @param key - A potential key value for this enum.
     * @return The provided key value, cast to the type of this enum's keys.
     * @throws {Error} if the provided string is not a valid key for this enum.
     */
    EnumWrapper.prototype.asKeyOrThrow = function (key) {
        if (this.isKey(key)) {
            return key;
        }
        else {
            throw new Error("Unexpected key: " + key + ". Expected one of: " + this.getValues());
        }
    };
    /**
     * Casts a string to a properly-typed key for this enum.
     * Returns a default key if the provided key is invalid.
     * @param key - A potential key value for this enum.
     * @param defaultKey - The key to be returned if the provided key is invalid.
     * @return The provided key value, cast to the type of this enum's keys.
     *         Returns `defaultKey` if the provided key is invalid.
     */
    EnumWrapper.prototype.asKeyOrDefault = function (key, defaultKey) {
        if (this.isKey(key)) {
            // type cast required to work around TypeScript bug:
            // https://github.com/Microsoft/TypeScript/issues/21950
            return key;
        }
        else {
            return defaultKey;
        }
    };
    /**
     * Tests if the provided value is a valid value for this enum.
     * Acts as a type guard to confirm that the provided value is actually the enum value type.
     * @param value - A potential value for this enum.
     * @return True if the provided value is valid for this enum.
     */
    EnumWrapper.prototype.isValue = function (value) {
        return value != null && this.keysByValueMap.has(value);
    };
    /**
     * Casts a value to a properly-typed value for this enum.
     * Throws an error if the value is invalid.
     * @param value - A potential value for this enum.
     * @return The provided value, cast to the type of this enum's values.
     * @throws {Error} if the provided value is not a valid value for this enum.
     */
    EnumWrapper.prototype.asValueOrThrow = function (value) {
        if (this.isValue(value)) {
            return value;
        }
        else {
            throw new Error("Unexpected value: " + value + ". Expected one of: " + this.getValues());
        }
    };
    /**
     * Casts a value to a properly-typed value for this enum.
     * Returns a default value if the provided value is invalid.
     * @param value - A potential value for this enum.
     * @param defaultValue - The value to be returned if the provided value is invalid.
     * @return The provided value, cast to the type of this enum's values.
     *         Returns `defaultValue` if the provided value is invalid.
     */
    EnumWrapper.prototype.asValueOrDefault = function (value, defaultValue) {
        if (this.isValue(value)) {
            return value;
        }
        else {
            return defaultValue;
        }
    };
    /**
     * Performs a reverse lookup from enum value to corresponding enum key.
     * Throws an error if the value is invalid.
     * NOTE: If this enum has any duplicate values, then one of the keys for the duplicated value is
     *       arbitrarily returned.
     * @param value - A potential value for this enum.
     * @return The key for the provided value.
     * @throws {Error} if the provided value is not a valid value for this enum.
     */
    EnumWrapper.prototype.getKeyOrThrow = function (value) {
        // NOTE: Intentionally not using isValue() or asValueOrThrow() to avoid making two key lookups into the map
        //       for successful lookups.
        var result = value != null ? this.keysByValueMap.get(value) : undefined;
        if (result != null) {
            return result;
        }
        else {
            throw new Error("Unexpected value: " + value + ". Expected one of: " + this.getValues());
        }
    };
    /**
     * Performs a reverse lookup from enum value to corresponding enum key.
     * Returns a default key if the provided value is invalid.
     * NOTE: If this enum has any duplicate values, then one of the keys for the duplicated value is
     *       arbitrarily returned.
     * @param value - A potential value for this enum.
     * @param defaultKey - The key to be returned if the provided value is invalid.
     * @return The key for the provided value.
     *         Returns `defaultKey` if the provided value is invalid.
     */
    EnumWrapper.prototype.getKeyOrDefault = function (value, defaultKey) {
        // NOTE: Intentionally not using isValue() to avoid making two key lookups into the map for successful lookups.
        var result = value != null ? this.keysByValueMap.get(value) : undefined;
        if (result != null) {
            return result;
        }
        else {
            return defaultKey;
        }
    };
    /**
     * Gets the enum value for the provided key.
     * Throws an error if the provided key is invalid.
     * @param key - A potential key value for this enum.
     * @return The enum value for the provided key.
     * @throws {Error} if the provided string is not a valid key for this enum.
     */
    EnumWrapper.prototype.getValueOrThrow = function (key) {
        // NOTE: The key MUST be separately validated before looking up the entry in enumObj to avoid false positive
        //       lookups for keys that match properties on Object.prototype, or keys that match the index keys of
        //       reverse lookups on numeric enums.
        return this.enumObj[this.asKeyOrThrow(key)];
    };
    /**
     * Gets the enum value for the provided key.
     * Returns a default value if the provided key is invalid.
     * @param key - A potential key value for this enum.
     * @param defaultValue - The value to be returned if the provided key is invalid.
     * @return The enum value for the provided key.
     *         Returns `defaultValue` if the provided key is invalid.
     */
    EnumWrapper.prototype.getValueOrDefault = function (key, defaultValue) {
        // NOTE: The key MUST be separately validated before looking up the entry in enumObj to avoid false positive
        //       lookups for keys that match properties on Object.prototype, or keys that match the index keys of
        //       reverse lookups on numeric enums.
        if (this.isKey(key)) {
            // type cast required to work around TypeScript bug:
            // https://github.com/Microsoft/TypeScript/issues/21950
            return this.enumObj[key];
        }
        else {
            return defaultValue;
        }
    };
    /**
     * Map of enum object -> EnumWrapper instance.
     * Used as a cache for {@link EnumWrapper.getCachedInstance} (and {@link $enum}).
     * NOTE: WeakMap has very fast lookups and avoids memory leaks if used on a temporary
     *       enum-like object. Even if a WeakMap implementation is very naiive (like a Map polyfill),
     *       lookups are plenty fast for this use case of a relatively small number of enums within
     *       a project. Just don't perform cached lookups inside tight loops when
     *       you could cache the result in a local variable, and you'll be fine :)
     *       {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap}
     *       {@link https://www.measurethat.net/Benchmarks/Show/2513/5/map-keyed-by-object}
     */
    EnumWrapper.instancesCache = new WeakMap();
    return EnumWrapper;
}());
exports.EnumWrapper = EnumWrapper;
/**
 * Alias of {@link EnumWrapper.getCachedInstance} for convenience.
 * Gets a cached EnumWrapper for an enum-like object.
 * Creates and caches a new EnumWrapper if one is not already cached.
 * @param enumObj - An enum-like object.
 * @return An instance of EnumWrapper for the provided enumObj.
 */
exports.$enum = EnumWrapper.getCachedInstance;
/**
 * Return true if the specified object key value is NOT an integer index key.
 * @param key - An object key.
 * @return true if the specified object key value is NOT an integer index key.
 */
function isNonIndexKey(key) {
    // If after converting the key to an integer, then back to a string, the result is different
    // than the original key, then the key is NOT an integer index.
    // See ECMAScript spec section 15.4: http://www.ecma-international.org/ecma-262/5.1/#sec-15.4
    return key !== String(parseInt(key, 10));
}
//# sourceMappingURL=index.js.map